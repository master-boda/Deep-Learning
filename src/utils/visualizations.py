import matplotlib.pyplot as plt 
import cv2
from PIL import Image
from sklearn.metrics import confusion_matrix
import seaborn as sns

plt.rc('figure', figsize=(10, 6))  
plt.rc('axes', labelsize=14)      
plt.rc('xtick', labelsize=12)     
plt.rc('ytick', labelsize=12)      
plt.rc('axes', titlesize=16)      
plt.rc('axes', linewidth=1.2)     
plt.rc('lines', linewidth=2)       
plt.rc('legend', fontsize=12)      
plt.rc('grid', linestyle='--', alpha=0.7) 

sns.set_style("ticks", {
    "axes.spines.left": True,
    "axes.spines.bottom": True,
    "axes.spines.top": False,
    "axes.spines.right": False
})
sns.set_palette('muted') 
sns.set_context("notebook", font_scale=1.2)  

plt.rcParams['font.family'] = 'Times New Roman'


def check_image_resolutions(metadata):
    """
    Check the resolutions of images listed in the metadata.
    
    Parameters:
        - metadata (pandas.DataFrame): A DataFrame containing image metadata (containing 'path_to_image' column).
        
    Returns:
        - resolutions (list): A list of tuples where each tuple contains the width and height of an image.
    """
    resolutions = []
    for idx, row in metadata.iterrows():
        with Image.open(row['path_to_image']) as img:
            resolutions.append(img.size)

    return resolutions

def plot_distribution_pie(data, col, ax=None, figsize=(10, 5)):
    """
    Plots a pie chart showing the distribution of values in a specified column of a DataFrame.
    Capable of displaying multiple pie charts in the same figure (useful for side by side comparisons).
    
    Parameters:
        - data (pd.DataFrame): The DataFrame containing the data.
        - col (str): The column name to plot the distribution.
        - ax (matplotlib.axes.Axes, optional): The axes on which to plot the pie chart. If None, a new figure and axes are created. Default is None.
        - figsize (tuple, optional): The size of the figure if ax is None. Default is (10, 5).
        
    Returns:
        None
    """
    counts = data[col].value_counts()
    # autopct='%1.1f%%' formats the percentage to have one decimal place
    # zip(counts.index, counts) contains the labels for the selected "col" and the respective counts
    counts.plot(kind='pie', autopct='%1.1f%%', labels=[f'{label} ({count})' for label, count in zip(counts.index, counts)], ax=ax)
    
    # ax used for displaying multiple plots in the same figure (useful for comparing distributions)
    if ax is None:
        plt.ylabel('')
        plt.title(f'Distribution of {col}')
        plt.show()
    else:
        ax.set_ylabel('')
        ax.set_title(f'Distribution of {col}')

def plot_images_compare_magnification(data, cancer_types, magnifications):
    """
    Plots a comparison of images from different magnifications for each cancer type.
    
    Parameters:
        - data (pd.DataFrame): DataFrame containing the image data with the columns 'Cancer Type', 'Magnification', and 'path_to_image'.
        - cancer_types (list): List of cancer types to be compared.
        - magnifications (list): List of magnifications to be compared.
        
    Returns:
        None
    """
    # function to compare images from different magnifications for each cancer type
    fig, axes = plt.subplots(figsize=(25, 30), sharey=True, ncols=4, nrows=8)

    for j, cancer_type in enumerate(cancer_types):
        for i, mag in enumerate(magnifications):
            # filter the data for the selected cancer type and magnification
            temp_df = data[(data['Cancer Type'] == cancer_type) & (data['Magnification'] == mag)]

            # select a random
            random_id = temp_df.sample(n=1).index[0]
            image = cv2.imread(data['path_to_image'][random_id])

            axes[j][i].imshow(image)
            axes[j][i].set_title(f"{cancer_type} (Mag.= {mag})")
            axes[j][i].axis('off')
            
def plot_confusion_matrix(y_true, y_pred, class_names, save_to_file=False, filename='confusion_matrix.png'):
    """
    Plot confusion matrix using seaborn heatmap.
    
    Parameters:
        - y_true (array-like): The true labels.
        - y_pred (array-like): The predicted labels.
        - class_names (list): The names of the classes.
        
    Returns:
        None
    """
    cm = confusion_matrix(y_true, y_pred)
    plt.figure(figsize=(10, 7))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.title('Confusion Matrix')
    
    if save_to_file:
        plt.savefig(filename)
        plt.close()
    else:
        plt.show()
            
def visualize_augmented_images(X_train, datagen):
    """
    Visualizes augmented images generated by a data generator.
    This function takes the first 5 images from the training set, applies the data generator
    to create augmented versions of these images, and displays them in a 1x5 grid.

    Parameters:
        - X_train (numpy.ndarray): Array of training images.
        - datagen (ImageDataGenerator): Keras ImageDataGenerator instance for augmenting images.

    Returns:
        None
    """
    for x in X_train[:5]:
        x = x.reshape((1,) + x.shape)
        fig, ax = plt.subplots(1, 5, figsize=(20, 4))
        fig.suptitle('Augmented Images')
        for i, batch in enumerate(datagen.flow(x, batch_size=1)):
            if i >= 5:
                break
            ax[i].imshow(batch[0])
            ax[i].axis('off')
        plt.show()
        
def plot_training_history(history, metric='loss', title='Model Loss'):
    """
    Plots the training history of a TensorFlow model.
    
    Parameters:
        - model (tf.keras.Model): The trained TensorFlow model.
        - metric (str, optional): The metric to plot. Default is 'loss'.
        - title (str, optional): The title of the plot. Default is 'Model Loss'.
        
    Returns:
        None
    """
    plt.plot(history[metric])
    plt.plot(history[f'val_{metric}'])
    plt.title(title)
    plt.ylabel(metric)
    plt.xlabel('Epoch')
    plt.legend(['train', 'val'], loc='upper left')
    plt.show()
    
def plot_images_cancer_types(data, benign_types, malignant_types, magnifications):
    """
    Plots a comparison of images from different magnifications for each cancer type.
    
    Parameters:
        - data (pd.DataFrame): DataFrame containing the image data with the columns 'Cancer Type', 'Magnification', and 'path_to_image'.
        - benign_types (list): List of benign cancer types to be compared.
        - malignant_types (list): List of malignant cancer types to be compared.
        - magnifications (list): List of magnifications to be compared.
        
    Returns:
        None
    """
    nrows = 2  # two rows: one for benign, one for malignant
    ncols = 4  # four columns for each row
    
    fig, axes = plt.subplots(figsize=(25, 10), nrows=nrows, ncols=ncols, sharey=True)

    for j, cancer_type in enumerate(benign_types + malignant_types):
        row = 0 if cancer_type in benign_types else 1
        col = benign_types.index(cancer_type) if cancer_type in benign_types else malignant_types.index(cancer_type)

        for mag in magnifications:
            temp_df = data[(data['Cancer Type'] == cancer_type) & (data['Magnification'] == mag)]

            # random image
            random_id = temp_df.sample(n=1).index[0]
            image = cv2.imread(data.loc[random_id, 'path_to_image'])

            axes[row][col].imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
            axes[row][col].set_title(f"{cancer_type} (Mag.= {mag})", fontsize=18, fontweight='bold')
            axes[row][col].axis('off')

    plt.tight_layout()
    plt.show()

def image_dist_by_magnification(df):
    sns.countplot(data=df, x='Magnification', order=['40X', '100X', '200X', '400X'])
    plt.title("Image Distribution by Magnification")
    plt.show()

def plot_results(history, metric):
    """"
    Plot either the accuracy or loss of the model throught the training epochs,
    both for the training and validation sets.
    Parameters:
        history: The history of the model training.
        metric: The metric to plot. Either 'accuracy' or 'loss'.
    Returns:
        None
    """
    with plt.rc_context():
        '''plt.rc('lines', linewidth=1.5)  
        sns.set_palette('Blues_d')  
        sns.set_style('whitegrid', {"axes.spines.left": True, "axes.spines.bottom": True, "axes.spines.top": False, "axes.spines.right": False})
        plt.rcParams['font.family'] = 'Times New Roman'''

        if type(history) == dict:
            plt.plot(history[metric])
            plt.plot(history[f'val_{metric}'])
        else:
            plt.plot(history.history[metric])
            plt.plot(history.history[f'val_{metric}'])
        plt.title(f'Model\'s {metric.capitalize()}', fontsize=18, fontweight='bold', loc='left', pad=20)
        plt.ylabel(metric.capitalize())
        plt.xlabel('Epochs')
        plt.legend(['Train', 'Validation'], loc='upper left')

